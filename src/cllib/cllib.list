
animals.lisp
(defvar *animals-debug-use-built-in-data* nil "Do not read the file.") ...)
(defvar *animals-default-data* ...)
(defvar *animals-data* nil "The actual data tree.") ...)
(defcustom *animals-file-name* string "animals" ...)
(defun anml-get-question (old new) ...)
(defun get-string (fmt &rest args) ...)
(defun anml-add-article (str) ...)
(defun anml-chop-article (str) ...)
(defun fix-question (quest) ...)
(defun get-question (1st 2nd) ...)
(defun anml-finish (tail) ...)
(defun save-restore-animals (&optional what) ...)
(defun play-animals () ...)
(defclass node () ...)
(defmethod print-object ((nd node) (out stream)) ...)
(defcustom *network* hash-table (make-hash-table :test 'eq) ...)
(defun name->node (name) ...)
(defun mknode (name info &optional yes no) ...)
(defcustom *root-node* node ...)
(defun save-restore-network (&optional what) ...)
(defun resolve (&optional (root *root-node*)) ...)
(defun to-symbol (string) ...)
(defun concat-down (&rest args) ...)
(defun get-symbol (&rest args) ...)
(defun get-new-symbol (&rest args) ...)
(defun add-node (name node) ...)
(defun animals->network (&optional (data *animals-data*) (base "ANIMAL")) ...)
(defun play-game (&optional (root *root-node*)) ...)

base.lisp
(defpackage #:cllib ...)
(defun mk-path (default &rest make-pathname-args) ...)
(defcustom *datadir* pathname ...)
(defcustom *mail-host-address* simple-string ...)
(defcustom *user-mail-address* simple-string ...)
(defgeneric value (xx) ...)
(defgeneric code (xx) ...)

card.lisp
(defclass name () ...)
(defclass phone () ...)
(defclass address () ...)
(defclass card () ...)
(defun slot-val (obj slot &optional default) ...)
(defcustom *user-cards* list nil "*The user database of records.") ...)
(defun object-match-p (cc nm) ...)
(defun find-card (nm &optional (cards *user-cards*)) ...)
(defstruct card-output ...)
(defcustom *card-output-type* (or null card-output) nil ...)
(defcustom *user-bbdb-file* pathname ...)
(defcustom *user-vcard-file* pathname ...)
(defcustom *user-native-file* pathname ...)
(defconst +card-output-bbdb+ card-output ...)
(defconst +card-output-vcard+ card-output ...)
(defconst +card-output-pretty+ card-output ...)
(defun card-org/title (cc) ...)
(defun card-print-as-bbdb (cc out) ...)
(defconst +card-vcard-begin+ string "BEGIN:VCARD" "VCARD start marker") ...)
(defconst +card-vcard-end+ string "END:VCARD" "VCARD end marker") ...)
(defun card-print-as-vcard (cc out) ...)
(defun card-print-as-pretty (cc out) ...)
(defun name-print-as-bbdb (nm out) ...)
(defun name-print-as-vcard (nm out) ...)
(defun name-print-as-pretty (nm out) ...)
(defun phone-print-as-bbdb (ph out) ...)
(defun phone-print-as-vcard (ph out) ...)
(defun phone-print-as-pretty (ph out) ...)
(defun address-print-as-bbdb (adrs out) ...)
(defun address-print-as-vcard (adrs out) ...)
(defun address-print-as-pretty (adrs out) ...)
(defmacro define-print-method (cs) ...)
(define-print-method card) ...)
(define-print-method name) ...)
(define-print-method phone) ...)
(define-print-method address) ...)
(defun init-sans-null-args (obj list) ...)
(defmethod initialize-instance ((cc card) &rest args) ...)
(defcustom *card-apellations* list ...)
(defcustom *card-suffixes* list ...)
(defmethod initialize-instance ((nn name) &rest args) ...)
(defun vector-to-phone (vec) ...)
(defun vector-to-address (vec) ...)
(defun vector-to-card (vec) ...)
(defun card-read-bbdb (in ra) ...)
(defun card-read-vcard (in ra) ...)

check.lisp
(defun check-list-type (lst pred &key (key #'value) (out *standard-output*)) ...)
(defcustom *data-change-tolerance* double-float 0.25d0 ...)
(defun check-list-values (lst &key (tol *data-change-tolerance*) ...)
(defcustom *big-num* double-float (/ double-float-epsilon) ...)
(defun bad-num-p (num &optional (bn *big-num*)) ...)
(defun out-of-bounds-p (ll &key (key #'value) (bn *big-num*) (out t)) ...)

clhs.lisp
(defcustom *clhs-root* url ...)
(defcustom *clhs-root-local* pathname ...)
(defun clhs-snarf-examples (&key (root *clhs-root-local*) ...)
(defstruct clhs-version ...)
(defcustom *clhs-version-table* list ...)
(defparameter *clhs-alist* nil) ...)
(defparameter *clhs-issues* nil) ...)
(defparameter *clhs-version* nil) ...)
(defun clhs-read-map (map root old-path ver err) ...)
(defun clhs-read-issues (root err) ...)
(defcustom *clhs-hashtable* (or null hash-table) nil ...)
(defun clhs-init (&key ((:root *clhs-root*) *clhs-root*) (err *error-output*)) ...)
(defun clhs-write-entity (name html out) ...)
(defun clhs-write-entities (file &key ((:root *clhs-root*) *clhs-root*) force) ...)
(defun clhs-doc (symb &key (out *standard-output*) force ...)
(defun regenerate-etc-files () ...)

closio.lisp
(defcustom *closio-method* symbol nil ...)
(defun read-object (st char arg) ...)
(defun make-clos-readtable (&optional (rt (copy-readtable))) ...)
(defconst +clos-readtable+ readtable (make-clos-readtable) ...)
(defun write-slots (object out slots names) ...)
(defmethod print-object ((obj standard-object) (out stream)) ...)
(defun macroexpand-r (form) ...)

date.lisp
(defconst +day-sec+ fixnum (* 24 60 60) "The number of seconds per day.") ...)
(deftype days-t () '(signed-byte 20)) ...)
(deftype date-f-t () '(function (t) date)) ...)
(defmethod print-object ((dt date) (out stream)) ...)
(defun make-date-readtable (&optional (rt (copy-readtable))) ...)
(defconst +bad-date+ date (make-date) "*The convenient constant for init.") ...)
(defun date-mon-name (dt) ...)
(defun date-mon-offset (dt) ...)
(defun print-date-month (dt &optional (str t)) ...)
(defsubst date2num (dt) ...)
(defsubst date2time (dt) ...)
(defun time2date (num) ...)
(defun fix-date (dt) ...)
(defmacro mk-date (&rest args) ...)
(defsubst date2days (dt) ...)
(defsubst days2date (days) ...)
(defun num2date (num) ...)
(defun to-string (obj) ...)
(defun infer-timezone (obj &optional minutes) ...)
(defcustom +unix-epoch+ integer (encode-universal-time 0 0 0 1 1 1970 0) ...)
(defun unix-date (nn) ...)
(defun string-w3-datetime (str &key (start 0) end) ...)
(defun string-w3-dttm (str &key (start 0) end) ...)
(defun dttm->string (dttm &key (format :long) (tz 0) (dst nil dst-p)) ...)
(defun date2string (ye mo da) (format nil "~d-~2,'0d-~2,'0d" ye mo da)) ...)
(defun time2string (ho mi se) ...)
(defgeneric date-formatter (format se mi ho da mo ye dd dst tz) ...)
(defcustom *y2k-cut* (mod 100) 50 ...)
(defun fix-y2k (ye) ...)
(defun string->dttm (xx &key (start 0) end) ...)
(defun span->string (xx &aux (ax (abs xx))) ...)
(defun string->span (st &key (start 0) (end (length st))) ...)
(defun infer-month (mon) ...)
(defun days-week-day (days) ...)
(defsubst date-week-day (date) ...)
(defgeneric date (xx) ...)
(defun days-since (key beg) ...)
(defun days-since-f (key beg) ...)
(defun today () ...)
(defun date= (d0 d1) ...)
(defun date/= (d0 d1) ...)
(defun date< (d0 d1) ...)
(defun date> (d0 d1) ...)
(defun date<= (d0 d1) ...)
(defun date<=3 (d0 d1 d2) ...)
(defun date<3 (d0 d1 d2) ...)
(defun date>= (d0 d1) ...)
(defun date>=3 (d0 d1 d2) ...)
(defun date>3 (d0 d1 d2) ...)
(defun date=*1 (&rest dates) ...)
(defun date=* (date1 &rest dates) ...)
(defsubst date-max (d0 d1) ...)
(defsubst date-min (d0 d1) ...)
(defun date-latest (ll &key (key #'date)) ...)
(defun date-earliest (ll &key (key #'date)) ...)
(defun next-month-p (d0 d1) ...)
(defun date-month= (d0 d1) ...)
(defun next-quarter-p (d0 d1) ...)
(defun date-quarter (dt) ...)
(defun date-quarter= (d0 d1) ...)
(defsubst days-between (d0 &optional (d1 (today))) ...)
(defun tomorrow (&optional (dd (today)) (skip 1)) ...)
(defsubst yesterday (&optional (dd (today)) (skip 1)) ...)
(defun date-next-year (dd &optional (skip 1)) ...)
(defun date-next-month (dd &optional (skip 1)) ...)
(defun date-next-all (dd &optional (skip 1)) ...)
(defun working-day-p (&optional (dd (today))) ...)
(defun days-to-next-working-day (&optional (date (today)) (skip 1)) ...)
(defsubst next-working-day (&optional (date (today)) (skip 1)) ...)
(defsubst previous-working-day (&optional (date (today)) (skip 1)) ...)
(defcustom *black-day-week* (mod 7) 4 "*Friday.") ...)
(defcustom *black-day-date* (mod 32) 13 "*13th.") ...)
(defun black-days (&key (start (today)) (end 1) ...)
(defun date-in-list (dt lst &optional (key #'date) last) ...)
(defun sync-dates (lists &key labels key cpy set (out *standard-output*) ...)
(defmacro sync-dates-ui (lists &key labels key cpy (out '*standard-output*) ...)

datedl.lisp
(defmethod code ((dl dated-list)) (dated-list-code dl)) ...)
(defconst +bad-dl+ dated-list (make-dated-list) ...)
(defsubst dl-ll (dl) ...)
(defsetf dl-ll (dl) (ls) ...)
(defsetf dl-fl (dl) (ls) ...)
(defun dl-reset (dl) ...)
(defun mk-dl (ll &rest others) ...)
(defsubst dl-date (dl) ...)
(defsubst dl-val (dl) ...)
(defsubst dl-chg (dl) ...)
(defsubst dl-misc (dl) ...)
(defsubst dl-slot (dl slot) ...)
(defsubst dl-len (dl) ...)
(defun dl-full-len (dl) ...)
(defsubst dl-endp (dl) ...)
(defun dl-nth (dl &optional (nn 0)) ...)
(defun dl-nth-date (dl &optional (nn 0)) ...)
(defun dl-nth-val (dl &optional (nn 0)) ...)
(defun dl-nth-chg (dl &optional (nn 0)) ...)
(defun dl-nth-misc (dl &optional (nn 0)) ...)
(defun dl-nth-slot (dl slot &optional (nn 0)) ...)
(defun dl-last-date (dl) ...)
(defmethod print-object ((dl dated-list) (out stream)) ...)
(defmethod describe-object ((dl dated-list) (out stream)) ...)
(defmacro with-saved-dl (dl &body body) ...)
(defmacro with-truncated-dl ((dl bd ed) &body body) ...)
(defmacro with-saved-dls ((&rest dls) &body body) ...)
(defcustom *rollover-bad-date* symbol nil ...)
(defun rollover (list &optional (datef #'date)) ...)
(defun date-in-dated-list (dt dl &optional last) ...)
(defun dl-double-date-p (dt dl) ...)
(defcustom *dl-max-overlap* index-t 100 ...)
(defun dl-overlap (dl &optional (out *standard-output*)) ...)
(defun dl-shift (dl &optional (dt 1)) ...)
(defun dl-next-chg (dl) ...)
(defun dl-count-jumps (dl &optional (key #'date-ye) (test #'eql)) ...)
(defun dl-jumps (dl) ...)
(defun dl-jumps-ui (dl &optional (out t)) ...)
(defun skip-dl-to-date (dl dt &optional stlog) ...)
(defun skip-dl-to-extremum (dl) ...)
(defun print-dated-lists (begd endd &rest dls) ...)
(defun volatility-dl (dl &rest opts &key (split #'date-ye) (key (dl-val dl)) ...)
(defun print-volatilities (ls &key (out t) (dl #'identity) (head #'identity)) ...)
(defun exp-mov-avg (coeff seq &optional (key #'value) date) ...)
(defun exp-mov-avg-append (coeff seq) ...)
(defun exp-mov-avg-dl (coeff idl &optional double (slot 'val)) ...)
(defun regress-dl (dl &optional begd endd) ...)
(defsubst mean-dl (dl &key (slot 'val)) ...)
(defun standard-deviation-dl (dl &rest opts &key (slot 'val) ...)
(defsubst standard-deviation-relative-dl (dl &key (slot 'val)) ...)
(defsubst mean-dl-weighted (dl wts &key (slot 'val)) ...)
(defmethod date ((xx change)) (change-date xx)) ...)
(defmethod value ((xx change)) (change-val xx)) ...)
(defsubst change-max-p (chg) ...)
(defsubst change-min-p (chg) ...)
(defsubst change-type (chg) ...)
(defsubst change-type= (ch1 ch2) ...)
(defmethod print-object ((chg change) (out stream)) ...)
(defsubst change-list-to-dated-list (chl &rest args) ...)
(defun dl-extrema (dl) ...)
(defmethod date ((xx diff)) (diff-date xx)) ...)
(defmethod value ((xx diff)) (diff-di xx)) ...)
(defsubst diff-list-to-dated-list (dl &rest args) ...)
(defmethod print-object ((df diff) (out stream)) ...)
(defun diff-lists (ls0 ls1 &key (date0 #'date) (date1 #'date) ...)
(defun check-dates (lst order-p same-p jump gap &key (date #'date) ...)

doall.lisp
(defun do-all (monitorp func answers &rest args) ...)

elisp.lisp
(defpackage emacs-lisp ...)
(defconst +elisp-pack+ package (find-package :el) ...)
(defmacro el::if (ii tt &rest ee) ...)
(defmacro el::let ((&rest vars) &rest forms) ...)
(defmacro el::let* ((&rest vars) &rest forms) ...)
(defmacro el::while (cc &body forms) ...)
(defun el::read-elisp-special (stream char) ...)
(defun el::make-elisp-readtable () ...)
(defconst +elisp-readtable+ readtable (el::make-elisp-readtable) ...)
(defun read-vector (stream char) ...)
(defun el::memq (elt list) (member elt list :test #'eq)) ...)
(defun el::delq (elt list) (delete elt list :test #'eq)) ...)
(defun el::member (elt list) (member elt list :test #'equal)) ...)
(defun el::delete (elt list) (delete elt list :test #'equal)) ...)
(defun el::concat (&rest args) (apply #'concatenate 'string args)) ...)
(defun el::message (&rest args) (apply #'format t args)) ...)
(defun el::format (&rest args) (apply #'format nil args)) ...)
(defun el::put (symbol propname value) (setf (get symbol propname) value)) ...)
(defun el::fset (symbol def) ...)
(defun el::setcar (cons obj) (setf (car cons) obj)) ...)
(defun el::setcdr (cons obj) (setf (cdr cons) obj)) ...)
(defun el::ignore (&rest ignore) (declare (ignore ignore)) nil) ...)
(defun el::sit-for (sec &optional (ms 0) nodisp) ...)
(defun el::string-to-number (string &optional (base 10)) ...)
(defun el::/ (&rest args) ...)
(defun el::decode-time (&optional (time (get-universal-time))) ...)
(defun el::encode-time (second minute hour day month year &rest zone) ...)
(defun el::defalias (symbol def) ...)
(defmacro el::defgroup (&rest args) (declare (ignore args))) ...)
(defmacro el::defcustom (var val doc &key (type t) &allow-other-keys) ...)
(defmacro el::defface (name val doc &rest args) ...)
(defmacro el::defconst (name val doc) `(defconstant ,name ,val ,doc)) ...)
(defmacro el::eval-when-compile (&rest body) ...)
(defmacro el::setq-default (&rest body) `(setq ,@body)) ...)
(defmacro el::save-window-excursion (&rest body) `(progn ,@body)) ...)
(defmacro el::save-excursion (&rest body) `(progn ,@body)) ...)
(defmacro el::with-output-to-temp-buffer (&rest body) `(progn ,@body)) ...)
(defsubst el::number-to-string (number) (write-to-string number :radix 10)) ...)
(defsubst el::int-to-string (number) (el::number-to-string number)) ...)
(defsubst el::char-to-string (char) (string char)) ...)
(defsubst el::string-to-int (&rest args) (apply #'el::string-to-number args)) ...)
(defsubst el::file-truename (file) (truename file)) ...)
(defsubst el::file-exists-p (file) (probe-file file)) ...)
(defsubst el::substring (seq from &optional to) (subseq seq from to)) ...)
(defsubst el::% (x y) (rem x y)) ...)
(defsubst el::file-directory-p (ff) (probe-directory ff)) ...)
(defsubst el::sref (ar ix) (aref ar ix)) ...)
(defsubst el::set-default (sy va) (setf (symbol-value sy) va)) ...)
(defsubst el::default-value (sy) (symbol-value sy)) ...)
(defun el::run-hooks (&rest hooks) ...)
(defun el::add-hook (hook function &optional append local) ...)
(defun el::remove-hook (hook function &optional local) ...)
(defun el::add-to-list (list el) ...)
(defmacro defun-fake (func) ...)
(defun-fake el::define-key) ...)
(defun-fake el::make-sparse-keymap) ...)
(defun-fake el::substitute-key-definition) ...)
(defun-fake el::interactive) ...)
(defun-fake el::make-help-screen) ...)
(defun-fake el::help-for-help) ...)
(defun-fake el::start-kbd-macro) ...)
(defun-fake el::substitute-command-keys) ...)
(defun-fake el::display-color-p) ...)
(defun-fake el::propertize) ...)
(defun-fake el::make-mode-line-mouse-map) ...)
(defvar el::global-map (el::make-sparse-keymap)) ...)
(defvar el::help-char (code-char 8)) ...)
(defvar el::help-form nil) ...)
(defvar el::window-system nil) ...)
(defvar el::mode-line-format nil) ...)
(defvar el::buffer-read-only nil) ...)
(defvar el::indent-tabs-mode nil) ...)
(deftype el::sexp () 'list) ...)
(deftype el::file () 'string) ...)
(deftype el::hook () '(or list symbol)) ...)
(defun el::mapconcat (function sequence separator) ...)
(defun to-directory (path) ...)
(defun el::directory-files (directory &optional full match nosort) ...)
(defun el::expand-file-name (name &optional (default-dir (default-directory))) ...)
(defun el::autoload (function file &optional docstring interactive type) ...)
(defvar el::emacs-home ...)
(defvar el::site-lisp-dir ...)
(defvar el::load-path ...)
(defvar el::features nil) ...)
(defun el::featurep (feature) (el::memq feature el::features)) ...)
(defun locate-file (file &optional source-only) ...)
(defun el::load (file &optional noerror nomessage nosuffix must-suffix) ...)
(defun el::require (feature &optional file-name noerror) ...)
(defun compile-el-file (file) ...)
(defun el::provide (feature) (pushnew feature el::features)) ...)

fileio.lisp
(deftype file-size-t () '(unsigned-byte 32)) ...)
(defun file-size (fn) ...)
(defun dir-size (dir) ...)
(defun rename-files (from to) ...)
(defun file-header-alist (file) ...)
(defun count-sexps (form) ...)
(defun code-complexity (file) ...)
(defun write-list-to-stream (lst stream &optional (print-function #'prin1) ...)
(defun write-list-to-file (lst fout &optional (print-function #'prin1) ...)
(defun write-lines-to-file (lines file) ...)
(defun read-list-from-stream (stream read-function &key args (package +kwd+) ...)
(defun read-list-from-file (fin read-function &rest args) ...)
(defun read-lines-from-file (fin) ...)
(defun pr (obj &optional (str *standard-output*) (nice t)) ...)
(defun write-to-file (obj file &optional (nice t) &rest comments) ...)
(defun read-from-stream (str &key (repeat t)) ...)
(defun read-from-file (file &key (readtable *readtable*) repeat ...)
(defun append-to-file (file fmt &rest fmt-args) ...)
(defsubst read-trim (stream) ...)
(defun skip-blanks (stream) ...)
(defun read-non-blanks (stream) ...)
(defun skip-done (out line pos st) ...)
(defun skip-to-line (st ln &key out (start 0)) ...)
(defun skip-search (stream string &key out (start 0)) ...)
(defun skip-search-or (stream strings &optional out) ...)
(defun timestamp (&optional (time (get-universal-time))) ...)
(defun file-newer (f0 f1) ...)
(defun load-compile-maybe (file &key load-only-if-compiled force) ...)
(defsubst file-newest (f0 f1) ...)
(defun file-equal-p (file1 file2 &key offset1 offset2) ...)
(defun file-cmp (file1 file2 &key offset1 offset2) ...)
(defun latest-file (path &optional (nth 0)) ...)
(defun save-restore (what &key (name "~a") pre-save post-read var ...)

fin.lisp
(defun mgg-rate (apr &optional monthly) ...)
(defun mgg-discount (term apr &optional monthly) ...)
(defun mgg-monthly (principal term apr &optional monthly) ...)
(defun mgg-term (discount apr &optional monthly) ...)
(defun mgg-compare (principal term apr apr-pts &optional monthly) ...)
(defun mgg-prepay (principal term apr prepay &optional monthly) ...)
(defun mgg-payoff (principal payment apr &optional monthly) ...)
(defun mgg-interest (principal term apr &optional monthly) ...)
(defun black-scholes-roots (cu-str intrst time vltlt) ...)
(defun black-scholes-call (strike curr intrst time vltlt) ...)
(defun black-scholes-eput (strike curr intrst time vltlt) ...)
(defun solow-next-year (kap k-y sav dgn alpha) ...)
(defun k/k (sav dgn alpha) ...)
(defun solow (k-y-0 dgn alpha) ...)
(defstruct option ...)
(defmethod print-object ((o option) (s stream)) ...)
(defun option-signed (option quantity) ...)
(defun option-p&l (option stock) ...)
(defun option-break-even (option) ...)
(defun option-range-min (option) ...)
(defun option-range-max (option) ...)
(defun option-p&l-formula (option) ...)
(defun plot-options (option-list &rest opts ...)
(defun lognormal (xx) ...)
(defun luhn (cn &optional (out *standard-output*)) ...)

geo.lisp
(defun parse-geo-coord (st) ...)
(defun geo-location (str &key (start 0)) ...)
(defun print-geo-coords (coord &optional (out *standard-output*)) ...)
(defmethod print-object ((gd geo-data) (out stream)) ...)
(defcustom *census-gazetteer-url* url ...)
(defun cite-info (&key (url *census-gazetteer-url*) city state zip ...)
(defcustom *weather-url* url ...)
(defun weather-report (code &key (out t) (url *weather-url*)) ...)
(defmethod print-object ((ntn country) (out stream)) ...)
(defsubst country-pop-chg (ntn) ...)
(defcustom *geo-code-url* url ...)
(defcustom *geo-info-template* simple-string ...)
(defcustom *country-list* list nil "*The list of known countries.") ...)
(defsubst find-country (slot value &optional (ls *country-list*) ...)
(defun save-restore-country-list (&optional (save t)) ...)
(defun str-core (rr) ...)
(defun read-some-lines (st) ...)
(defun fetch-country-list () ...)
(defun dump-country (ntn &rest opts) ...)
(defun view-country (&rest find-args) ...)
(defmacro dump-find-country ((&rest find-args) ...)
(defun update-country (cc) ...)
(defun next-info (str skip &optional type) ...)
(defun add-note (cc &rest news) ...)
(defun parse-num (st) ...)

gnuplot.lisp
(defcustom *plot-default-backend* symbol :gnuplot ...)
(defcustom *gnuplot-path* simple-string ...)
(defconst +gnuplot-epoch+ integer (encode-universal-time 0 0 0 1 1 2000 0) ...)
(defcustom *gnuplot-printer* simple-string ...)
(defcustom *gnuplot-stream* (or null stream) nil ...)
(defcustom *gnuplot-file* pathname (merge-pathnames "plot.tmp" *datadir*) ...)
(defcustom *gnuplot-msg-stream* (or stream null) *standard-output* ...)
(defcustom *gnuplot-default-directive* t :plot ...)
(defcustom *gnuplot-dribble* (or null stream) nil ...)
(defsubst plot-sec-to-epoch (dt) ...)
(defmacro with-plot-stream ((str &rest options) &body body) ...)
(defgeneric plot-output (plot out backend) ...)
(defmethod plot-output ((pt plot-term) (out stream) (backend (eql :gnuplot))) ...)
(defun ps-terminal (target) ...)
(defcustom *plot-term-screen* plot-term ...)
(defcustom *plot-term-printer* plot-term (ps-terminal '*gnuplot-printer*) ...)
(defcustom *plot-term-file* plot-term (ps-terminal *gnuplot-file*) ...)
(defgeneric directive-term (directive) ...)
(defmethod plot-output ((pl plot-label) (out stream) ...)
(defmethod plot-output ((pt plot-timestamp) (out stream) ...)
(defconst +plot-timestamp+ plot-timestamp (make-plot-timestamp) ...)
(deftype range-limit () '(or real (eql *))) ...)
(defstruct coordinate ...)
(defstruct point ...)
(defstruct arrow ...)
(defmethod plot-output ((pt null) (out stream) (backend (eql :gnuplot))) ...)
(defmethod plot-output ((cr coordinate) (out stream) (backend (eql :gnuplot))) ...)
(defmethod plot-output ((pt point) (out stream) (backend (eql :gnuplot))) ...)
(defmethod plot-output ((arw arrow) (out stream) (backend (eql :gnuplot))) ...)
(defun %plotout (xx) ...)
(defmethod plot-output ((pa plot-axis) (out stream) (backend (eql :gnuplot))) ...)
(defun multiplot-row-col (mp data-fun) ...)
(defmethod plot-output ((ps plot-spec) (out stream) (backend (eql :gnuplot))) ...)
(defun make-plot (&key data-fun (plot *gnuplot-default-directive*) ...)
(defgeneric make-plot-stream (directive) ...)
(defun internal-with-plot-stream (body-function &rest opts ...)
(defun plot-data-style (num-ls) ...)
(defun plot-dated-lists (begd endd dls &rest opts &key (title "Dated Plot") ...)
(defun plot-lists (lss &rest opts &key (key #'value) (title "List Plot") rel ...)
(defun plot-lists-arg (lss &rest opts &key (key #'identity) ...)
(defun plot-error-bars (lss &rest opts &key (title "Error Bar Plot") ...)
(defun plot-functions (fnl xmin xmax numpts &rest opts &key data-style ...)
(defun plot-ulam (list &rest opts &key (title "Ulam spiral") &allow-other-keys) ...)
(defun plot-dated-lists-depth (depth dls slot &rest opts) ...)
(defun plot-histogram (list &rest opts &key (mean t) (key #'value) ...)
(defun dated-list-to-day-list (dl &key (slot 'val) (depth (dl-len dl))) ...)
(defun line-day2sec (ln begd) ...)
(defun plot-formula (formula beg end str title lt) ...)
(defun plot-line-str (ln beg end str &optional (title "") lt) ...)
(defun plot-quad-str (qu beg end str &optional (title "") lt) ...)

gq.lisp
(defpackage #:getquote ...)
(defcustom *gq-error-stream* (or null stream) *error-output* ...)
(defcustom *gq-timeout* (real 0) 600 ...)
(defun gq-complete-url (url &rest ticks) ...)
(defun mk-daily-data (&rest args) ...)
(defmethod print-object ((dd daily-data) (out stream)) ...)
(defun gq-guess-date () ...)
(defmacro with-url-xml ((var url &key (err '*error-output*) ...)
(defun get-url-xml-tokens (url &key (out *standard-output*) ...)
(defun stream-next-num (stream) ...)
(defun gq-dat (obj) ...)
(defun gq-next (stream &optional (nn 1)) ...)
(defun gq-skip (stream string) ...)
(defun gq-next-num (stream &optional (nn 1)) ...)
(defun date-mo/da/ye (xx) ...)
(defun get-quotes-apl (url &rest ticks) ...)
(defun get-quotes-yahoo (url &rest ticks) ...)
(defun get-quotes-sm (url &rest ticks) ...)
(defun get-quotes-pf (url &rest ticks) ...)
(defun get-quotes-cnn (url &rest ticks) ...)
(defun get-quotes-xmltoday (url &rest ticks) ...)
(defcustom *get-quote-url-list* list ...)
(defun get-quotes (server &rest ticks) ...)
(defun infer-date (&optional mon day) ...)
(defcustom *hist-data-file* pathname ...)
(defcustom *hist-data-file-header* simple-string ...)
(defcustom *hist-data-file-sep* symbol :~ ...)
(defcustom *holdings* list nil ...)
(defcustom *history* list nil ...)
(defun read-pfl (stream ra) ...)
(defmethod print-object ((pfl pfl) (out stream)) ...)
(defsubst find-pfl (sy) ...)
(defmethod value ((hs hist)) (hist-totl hs)) ...)
(defmethod date ((hs hist)) (hist-date hs)) ...)
(defmethod code ((pfl pfl)) (pfl-tick pfl)) ...)
(defun read-hist (stream ra) ...)
(defmethod print-object ((hist hist) (out stream)) ...)
(defun hist-totl-comp (hold navs) ...)
(defun read-data-file (file) ...)
(defun save-data (file hold hist) ...)
(defun navs= (nav1 nav2) ...)
(defun gq-fix-hist (hold hist hhh) ...)
(defun pr-res (out pref v0 v1 per apy v2 &optional (tc (percent-change v2 v0))) ...)
(defun show-results (tickers srv res &optional (out *standard-output*)) ...)
(defun process-results (hold hist srv res yea ...)
(defun plot-portfolio (hold hist plot) ...)
(defcustom *gq-log* pathname ...)
(defun update-quotes (&key (plot nil plotp) server debug ...)
(defun find-html-element (tree predicate) ...)
(defun find-html-elements (tree predicate &optional result) ...)
(defun html-match-form (pattern object) ...)
(defmacro html-match (pattern) ...)
(defmacro deftable (name constructor fields) ...)
(defstruct composition ...)
(defconst +bad-composition+ composition (make-composition) ...)
(deftable composition make-composition ...)
(defstruct holding ...)
(defstruct holdings ...)
(defun holdings-url (symbol) ...)
(defun holdings (&key symbol) ...)
(defun percent-of-string (string) ...)
(defun comma-int-of-string (string) ...)
(defun dollar-of-string (string) ...)
(defstruct breakdown ...)
(defconst +bad-breakdown+ breakdown (make-breakdown) ...)
(deftable breakdown make-breakdown ...)
(defstruct holder ...)
(defstruct holders ...)
(defun holders-url (symbol) ...)
(defun holders (&key symbol) ...)

h2lisp.lisp
(defstruct c-dim "C dimension." dim) ...)
(defstruct c-cmt "C comment." data) ...)
(defun read-standalone-char (stream char) (declare (ignore stream)) char) ...)
(defun read-c-object (stream char) ...)
(defun make-c-readtable (&optional (rt (copy-readtable))) ...)
(defparameter *c-readtable* (make-c-readtable) "The readtable for C parsing.") ...)
(defun read-statement (ts) ...)
(defparameter *c-types* '(int uint char) "Known C types.") ...)
(defparameter *c-un-types* nil "UnKnown C types.") ...)
(defun c-see-type (sym) ...)
(defun c-def-type (sym) ...)
(defun c-convert-decl (lst) ...)
(defun c-number (obj) ...)
(defun c-eval (lst) ...)
(defgeneric h2lisp (in out) ...)
(defmethod h2lisp ((in stream) (out stream)) ...)

html.lisp
(defstruct html-tag data) ...)
(defcustom *html-specials* list ...)
(defun html-translate-specials (str &optional space) ...)
(defun strip-html-markup (str) ...)
(defun read-html-markup (stream char) ...)
(defun make-html-readtable (&optional (rt (copy-readtable))) ...)
(defcustom *html-readtable* readtable (make-html-readtable) ...)
(defclass html-stream-in (fundamental-character-input-stream) ...)
(defcustom *html-unterminated-tags* list '(:p :li :dd :dt :tr :td :th) ...)
(defun html-end-tag (tag) ...)
(defmethod stream-read-char ((in html-stream-in)) ...)
(defmethod stream-unread-char ((in html-stream-in) (char character)) ...)
(defmethod stream-read-char-no-hang ((in html-stream-in)) ...)
(defmethod stream-peek-char ((in html-stream-in)) ...)
(defmethod stream-listen ((in html-stream-in)) ...)
(defmethod stream-read-line ((in html-stream-in)) ...)
(defmethod stream-clear-input ((in html-stream-in)) ...)
(defcustom *ts-kill* list nil "*The list of extra characters to kill.") ...)
(defun ts-pull-next (ts &optional (concat-p t) (kill *ts-kill*)) ...)
(defun read-next (ts &key errorp (kill *ts-kill*) skip) ...)
(defun ts-skip-scripts (ts) ...)
(defun next-token (ts &key (num 1) type dflt (kill *ts-kill*)) ...)
(defun next-number (ts &key (num 1) (kill *ts-kill*)) ...)
(defun skip-tokens (ts end &key (test #'eql) (key #'identity) kill) ...)
(defun dump-url-tokens (url &key (fmt "~3d: ~a~%") ...)
(defun xml-read-from-url (url &key (repeat t) ...)

iter.lisp
(defun vector< (s0 s1 &key (test #'=) (lessp #'<) (key #'identity)) ...)
(defsubst maj2ind (ls ix &optional (ii (make-list (length ls)))) ...)
(defmacro do-iter-ls ((ii idx &optional ret) &body body) ...)
(defmacro do-iter ((ii idx &optional ret) &body body) ...)
(defun envelope (lst) ...)
(defun convex-hull-n-dim (lst) ...)
(defun optimize-pars (func pars steps nns add &optional (out t) (ni 0) (de 0)) ...)

laser.lisp
(defun done-files (action &rest fl) ...)
(defun print-files (printer &rest file-paths) ...)
(defcustom *nprint-path* pathname (pathname "z:/public/nprint.exe") ...)
(defcustom *nprint-switch* simple-string "/q=ddslaser" ...)
(defcustom *nprint-tmp-file* pathname ...)
(defcustom *print-line-printer* simple-string ...)
(defcustom *print-portrait* simple-string "&l0O" ...)
(defcustom *print-landscape* simple-string "&l1O" ...)
(defcustom *print-eject-page* simple-string "&l0H" ...)
(defcustom *print-weight-bold* simple-string "(s3B" ...)
(defcustom *print-weight-medium* simple-string "(s0B" ...)
(defcustom *print-weight-light* simple-string "(s-3B" ...)
(defcustom *print-weight-boldness* simple-string ...)
(defcustom *print-style-upright* simple-string "(s0S" ...)
(defcustom *print-style-italic* simple-string "(s1S" ...)
(defcustom *print-style-condensed* simple-string "(s4S" ...)
(defcustom *print-underline-on* simple-string "&d3D" ...)
(defcustom *print-underline-off* simple-string "&d@" ...)
(defmacro with-output-to-nprint ((ostr (&rest pre) &optional (post "E")) ...)
(defmacro with-printing ((out &key printer pre) &body body) ...)
(defun test-printing () ...)

list.lisp
(defun jumps (seq &key (pred #'eql) (key #'value) args (what :both)) ...)
(defun count-jumps (seq &key (pred #'eql) (key #'value) args) ...)
(defun freqs (seq &key (test #'eql) (key #'identity)) ...)
(defun nsplit-list (lst &key (pred #'eql) (key #'identity) (obj nil objp)) ...)
(defmacro with-sublist ((newl oldl e0 e1 &key (key '#'identity) (test '#'eql)) ...)
(defmacro with-nsplit ((newl oldl &rest split-args) &body body) ...)
(defun call-on-split (lst func &rest args &key (split-key #'value) ...)

log.lisp
(defun list-format (item-fmt) ...)
(defun fmt% (number) ...)
(defun get-int-time (&optional (run t)) ...)
(defun time-diff (end beg) ...)
(defun elapsed (bt run &optional fmt) ...)
(defcustom *print-log* simple-vector ...)
(defun print-log-p (type) ...)
(defmacro mesg (type str &rest args) ...)
(defmacro with-timing ((&key (terpri t) (done nil) (run t) (real t) ...)

math.lisp
(define-modify-macro mulf (mult) * "Multiply the arg by a number.") ...)
(define-modify-macro divf (mult) / "Divide the arg by a number.") ...)
(defmacro sqr (xx) ...)
(defun triangle (i) ...)
(defun product-from-to (aa bb) ...)
(defun binomial (nn kk) ...)
(defun binomial-mod2 (nn kk) ...)
(defun ! (nn) ...)
(defun !! (nn) ...)
(defun stirling (xx) ...)
(defun fibonacci (nn) ...)
(defun ruler (n) ...)
(defun has-divisors (num num-list &optional (rt (isqrt num))) ...)
(defcustom *primes* list nil "The list of primes. ...)
(defcustom *primes-file* pathname (merge-pathnames "primes" *datadir*) ...)
(defun primes-to (nn &optional int) ...)
(defun divisors (nn &optional (primes-list (primes-to (1+ (isqrt nn))))) ...)
(defsubst primep (nn &optional (primes-list (primes-to (1+ (isqrt nn))))) ...)
(defun make-primes-list (&optional (limit most-positive-fixnum)) ...)
(defun number-sum-split (num fun fun-1 &optional (out *standard-output*)) ...)
(defun all-num-split (min find fun &optional int) ...)
(defun make-vector-indexed (len) ...)
(defun vector-shuffle (vec) ...)
(defun permutation (vec nth &optional (len (1- (length vec))) (fact (! len))) ...)
(defmacro with-permutations-shuffle ((var vec &optional ret-form) &body body) ...)
(defun check-permutations-end (name found length) ...)
(defmacro with-permutations-swap ((var vec &optional ret-form) &body body) ...)
(defmacro with-permutations-lex ((var len &optional ret-form) &body body) ...)
(defun permutations-list (vec &key (method :lex)) ...)
(defun subsets (set) ...)
(defun draw (distrib) ...)
(defun pick (seq &optional distrib) ...)
(defun sample (seq count &key complement) ...)
(defun sample-lines (count &key (in (port:required-argument)) ...)
(defun eval-cont-fract (fract) ...)
(defcustom *num-tolerance* double-float #.(sqrt double-float-epsilon) ...)
(defsubst approx=-abs (f0 f1 &optional (tol *num-tolerance*)) ...)
(defsubst approx=-rel (f0 f1 &optional (tol *num-tolerance*)) ...)
(defcustom *relative-tolerance* double-float 1d-3 ...)
(defcustom *absolute-tolerance* double-float 1d0 ...)
(defsubst approx= (v0 v1 &optional (rt *relative-tolerance*) ...)
(defun fract-approx (xx &optional (eps *num-tolerance*)) ...)
(defun dot (l0 l1 &key (key #'value) (key0 key) (key1 key)) ...)
(defun poly1 (var &rest coeffs) ...)
(defun poly (var coeffs) ...)
(defun erf (x) ...)
(defun erfc (x) ...)
(defun erfcx (x) ...)
(defun cndf (x) ...)
(defun cndf-tail (x) ...)
(defun continued-fraction (n0 d0 num den) ...)
(defun log-gamma (x) ...)
(defun beta (x y) ...)
(defun incomplete-gamma (a x &optional (log-gamma-a (log-gamma a))) ...)
(defvar *max-iterations* 1000 "The maximum permitted number of iterations.") ...)
(defun incomplete-gamma-error (f a x log-gamma-a n v delta) ...)
(defun incomplete-gamma-series (a x &optional (log-gamma-a (log-gamma a))) ...)
(defun incomplete-gamma-continued-fraction ...)
(defun norm-functions (order) ...)
(defun norm (seq &key (key #'value) (order 1)) ...)
(defun normalize (seq &optional (norm #'norm)) ...)
(defun rel-dist (seq1 seq2 &key (key #'value) (start1 0) (start2 0) depth) ...)
(defun mean (seq &key (key #'value) (len (length seq))) ...)
(defun mean-weighted (seq wts &key (value #'value) (weight #'value)) ...)
(defun mean-geometric (seq &key (key #'value)) ...)
(defun mean-geometric-weighted (seq wts &key (value #'value) (weight #'value)) ...)
(defun mean-some (seq &key (key #'value)) ...)
(defmacro min+max (val min min$ max max$) ...)
(defun standard-deviation (seq &key (len (length seq)) (key #'value) ...)
(defun standard-deviation-weighted (seq wts &key ...)
(defsubst standard-deviation-cx (&rest args) ...)
(defun standard-deviation-relative (seq &key (key #'value)) ...)
(defun entropy-distribution (seq &key (count #'value)) ...)
(defun entropy-ht (ht) ...)
(defun entropy-sequence (seq &key (key #'value) (test 'eql) (weight 1)) ...)
(defun kullback-leibler (seq1 seq2 &key (key1 #'value) (key2 #'value)) ...)
(defun mutual-information-N (seq &key (key #'value) (test 'eql)) ...)
(defun discretize-by-width (min max nbin &key logscale) ...)
(defun mutual-information-continuous (seq &key (key #'identity) nbin ...)
(defun kurtosis-skewness (seq &key (key #'value) std mean len) ...)
(defun kurtosis-skewness-weighted (seq wts &key std mean tot ...)
(defun covariance (seq0 seq1 &key (key0 #'value) (key1 #'value)) ...)
(defun covariance1 (seq0 seq1 &key (key0 #'value) (key1 #'value) ...)
(defsubst cov (seq &key (xkey #'car) (ykey #'cdr)) ...)
(defun volatility (lst split-key &rest args ...)
(defconst +bad-mdl+ mdl (make-mdl) "The convenient constant for init.") ...)
(defmethod value ((mdl mdl)) (mdl-mn mdl)) ...)
(defmethod print-object ((mdl mdl) (out stream)) ...)
(defun standard-deviation-mdl (seq &key (key #'value) weight discrete) ...)
(defun mdl-normalize (value mdl)   (/ (- value (mdl-mn mdl)) (mdl-sd mdl))) ...)
(defun mdl-denormalize (value mdl) (+ (* value (mdl-sd mdl)) (mdl-mn mdl))) ...)
(defun mdl-normalize-function (function mdl) ...)
(defun normalizer-table (functions list &key (out *standard-output*) ...)
(defun normalize-function-list (fl mdl-ht) ...)
(defun check-probabilities (p12 p1 p2 N caller) ...)
(defsubst info-component (p12 p1 p2) ...)
(defun information (p &optional (N 1) &aux (q (- N p))) ...)
(defun mutual-information-2 (p12 p1 p2 &optional (N 1) ...)
(defun dependency-2 (p12 p1 p2 &optional (N 1)) ...)
(defun proficiency-2 (p12 p1 p2 &optional (N 1)) ...)
(defun correlation-2 (p12 p1 p2 &optional (N 1) ...)
(defun 1st-moment (p12 p1 p2) ...)
(defmacro safe-fun (func pred &optional default) ...)
(defmacro safe-fun1 (func pred &optional default) ...)
(defun safe-/ (aa &rest bb) ...)
(defsubst s/ (aa bb) ...)
(defsubst d/ (aa bb) ...)
(defun convex-hull1 (lst up &key (xkey #'car) (ykey #'cdr)) ...)
(defun convex-hull (lst up &key (xkey #'car) (ykey #'cdr)) ...)
(defun sharpe-ratio (seq &key (key #'value)) ...)
(defmacro to-percent (vv) ...)
(defun percent-change (v0 v1 &optional days) ...)
(defun rel-diff (v0 v1) ...)
(defun mid-real (beg end) (/ (+ beg end) 2)) ...)
(defun mid-integer (beg end) (ash (+ beg end) -1)) ...)
(defun binary-search (beg end func &key (fmid #'mid-real)) ...)
(defun newton (ff &key (val 0) (ival val) (*num-tolerance* *num-tolerance*) ...)
(defun integrate-simpson (ff x0 xm &optional (*num-tolerance* *num-tolerance*)) ...)
(defun ode1 (f &key (y0 0) (x0 0) (dx 0.1) (x1 1)) ...)
(defun add-probabilities (&rest pp) ...)
(defconst +bad-line+ line (make-line) "*The convenient constant for init.") ...)
(defmethod print-object ((ln line) (out stream)) ...)
(defsubst line-val (ln par) ...)
(defsubst line-rsl (ln) ...)
(defsubst line-below-p (ln xx yy) ...)
(defsubst line-above-p (ln xx yy) ...)
(defun intersect (line x0 y0 x1 y1) ...)
(defmacro with-line (ln xx yy above below upon ...)
(defsubst line-adjust (ln xx yy) ...)
(defun line-adjust-dir (ln xx yy up) ...)
(defun line-adjust-list (ln ls up &key (xkey #'car) (ykey #'cdr)) ...)
(defsubst line-thru-points (x0 y0 x1 y1) ...)
(defun regress (seq &key (xkey #'car) (ykey #'cdr)) ...)
(defsubst lincom (c0 x0 c1 x1) ...)
(defstruct plf ...)
(defun plf-val (plf par) ...)
(defun monotonic-p (vec &key (key #'value)) ...)
(defun plf-monotonic-p (plf) (monotonic-p (plf-y plf) :key #'identity)) ...)
(defun plf->function (plf) (lambda (x) (plf-val plf x))) ...)
(defun plf-size (plf &aux (size (length (plf-x plf)))) ...)
(defun plf-integral (plf) ...)
(defun remove-elements (pos-list vec) ...)
(defun plf-simplify (plf) ...)
(defcustom *increasify-step* (real 0 (1/2)) 3d-1 ...)
(defun increasify (vec &key (step *increasify-step*)) ...)
(defcustom *ulam-base* integer 0 ...)
(defun ulam-n2xy (n &key ((:base *ulam-base*) *ulam-base*) ...)
(defun ulam-xy2n (x y &key ((:base *ulam-base*) *ulam-base*) ...)
(defun show-ulam (x y &key ((:base *ulam-base*) *ulam-base*) ...)

miscprint.lisp
(defun ascii-char (ch &optional (str *standard-output*)) ...)
(defun print-all-ascii (&optional (str *standard-output*)) ...)
(defun print-package (pp &optional (out *standard-output*) verbose) ...)
(defun print-all-packages (&optional (out *standard-output*)) ...)
(defun hash-table-keys (ht) ...)
(defun hash-table->alist (ht) ...)
(defun alist->hash-table (alist) ...)
(defun pophash (object ht) ...)
(defun copy-hash-table (ht) ...)
(defun print-counts (count-ht &key (out *standard-output*) (key-numeric-p nil) ...)
(defun make-ht-readtable (&optional (rt (copy-readtable))) ...)
(defmethod print-object ((ht hash-table) (out stream)) ...)
(defun alist->plist (al) ...)
(defun plist->alist (pl) ...)
(defun plist= (p1 p2 &key (test #'eql)) ...)
(defun alist= (a1 a2 &key (test #'eql)) ...)

octave.lisp
(defun dot0 (l0 l1 &key (key #'value) key0 key1) ...)
(defcustom *octave-program* simple-string ...)
(defun solve-lin (mx vec &optional dump) ...)

rpm.lisp
(defmethod url ((dld download-data)) (dld-url dld)) ...)
(defun rpm-list-size (rpms) ...)
(defmethod print-object ((dld download-data) (out stream)) ...)
(defun dld-reset (dld) ...)
(defcustom *rpm-present* simple-vector (make-array 0) ...)
(defcustom *rpm-locations* list ...)
(defcustom *rpm-locations-timeout* integer (* 3600 6) ...)
(defcustom *rpm-local-paths* list '(#p"/var/tmp/RPMS/") ...)
(defcustom *rpm-local-target* pathname #p"/var/tmp/" ...)
(defcustom *rpm-command-line* simple-string ...)
(defcustom *rpm-timeout* index-t 600 ...)
(defcustom *rpm-max-retry* (or null index-t) 10 ...)
(defconst +bad-rpm+ rpm (make-rpm) "*The convenient constant for init.") ...)
(defmethod print-object ((rpm rpm) (out stream)) ...)
(define-condition rpm-error (file-error code) () ...)
(defun del-file (file &optional (out *standard-output*)) ...)
(defun rpm-file (rpm &optional dir) ...)
(defsubst rpm-pos (name) ...)
(defun rpm-skip-p (rpm) ...)
(defcustom *rpm-skip* (or (function (rpm) boolean) string null) #'rpm-skip-p ...)
(defun short-string-to-rpm (name) ...)
(defgeneric rpm (obj) ...)
(defmethod rpm ((obj string)) ...)
(defun rpm= (r0 r1) ...)
(defun rpm< (r0 r1) ...)
(defun rpm=< (r0 r1) ...)
(defun version< (v0 v1) ...)
(defun release< (v0 v1) ...)
(defun rpm-merge-notes (r0 r1) ...)
(defun rpm-read (in) ...)
(defun rpm-installed () ...)
(defun rpm-path-valid-p (path) ...)
(defun rpm-downloaded () ...)
(defun rpm-present () ...)
(defun rpm-available (url &key (out *standard-output*) (err *error-output*) ...)
(defun rpm-prune-list (rpms) ...)
(defun rpm-print (rpm &optional idx (out *standard-output*)) ...)
(defun rpm-get-available (&key force (out *standard-output*) ...)
(defun show-rpms (&optional (what "") (local t)) ...)
(defun delete-rpms (what) ...)
(defun rpm-current (name) ...)
(defun rpm-to-be-installed () ...)
(defun rpm-get-present (&optional force (out *standard-output*)) ...)
(defun rpm-get-list (url rpms &key (out *standard-output*) (err *error-output*) ...)
(defun rpm-get-new-rpms (&key force (out *standard-output*) ...)
(defun rpm-list-rpm (name &key (out *standard-output*) (err *error-output*) ...)
(defun rpm-clean-hdr (dir &optional (out *standard-output*)) ...)
(defun rpm-clean-up (&key (out *standard-output*) total-list ...)
(defun local-host (sock) ...)
(defun local-port (serv) ...)
(defun ftp-port-command (sock serv) ...)

server.lisp
(defcustom *cl-server-port* integer 453 ...)
(defcustom *cl-server-password* (or null simple-string) "ansi-cl" ...)
(defcustom *cl-server-quit* list '("bye" "quit" "exit") ...)
(defun cl-server-mesg (sock fmt &rest args) ...)
(defun cl-server (&key (port *cl-server-port*) (password *cl-server-password*)) ...)
(defun start-lisp-connection-listener (&key (port 1025) ...)

simple.lisp
(defmacro with-collect ((&rest collectors) &body forms) ...)
(defun filter (lst test collect &key (key #'identity)) ...)
(defmacro lexicographic-comparison (functions &key (eq '=) (gt '>) (ge '>=)) ...)
(defmacro ensure (form default) ...)
(defsubst below-p (x0 y0 x1 y1 x2 y2) ...)
(defsubst linear (x0 y0 x1 y1 tt) ...)
(defun ppprint-list (lst &optional (stream t)) ...)
(defun nsublist (lst &optional pos0 pos1) ...)
(defun fix-list (ls) ...)
(defsubst to-list (zz) ...)
(defsubst from-list (zz) ...)
(defun flatten (ll) ...)
(defun zero-len-p (seq) ...)
(defsubst paste (new ls) ...)
(defun skip-to-new (lst &key (test #'eql) (key #'value)) ...)
(defun list-length-dotted (list) ...)
(defun set= (set1 set2 &rest rest &key key test test-not) ...)
(defun count-all (seq &key (test 'eql) (key #'value) append (weight 1) ...)
(defun find-duplicates (seq &key (test 'eql) (key #'value)) ...)

sorted.lisp
(defmacro plunge-into (new newk lst len maxlen kend pred key) ...)
(defmacro plunge-into-idx (new newk lst len maxlen kend pred key idx nkey) ...)
(defun top-bottom (seq maxn minn mk-idx ...)
(defun top-bottom-ui (seq maxn minn idx &key (key #'value) (lessp #'<) ...)
(defun top-bottom-fl (ls &key (val #'value) (label #'identity) ...)
(defmacro process-and-shift (pred akey ckey t0 e0 k0 t1 e1 k1) ...)
(defun map-sorted (type func pred l0 l1 ...)
(defun reduce-sorted (rfunc func2 pred l0 l1 ...)
(defun sorted-map (type func pred missing ckey akey &rest lists) ...)
(defun delete-duplicate-entries (lst &key (key #'identity) (test #'eql) ...)
(defun multi-union (pred ckey &rest lists) ...)
(defun binary-pos (el vect &key (test #'<) (key #'identity) (start 0) ...)
(defun binary-member (el ls &key (key #'identity) (test #'<)) ...)

stat.lisp
(defun regress-n (yy xx nx &key (func #'aref)) ...)
(defun regress-poly (seq deg &key (xkey #'car) (ykey #'cdr)) ...)
(defun histogram (list &key (key #'value) (out *standard-output*) logscale ...)
(defun check-distrib (distrib) ...)
(defun chi2-1 (sample distrib) ...)
(defun chi2-2 (sample1 sample2) ...)
(defun chi2-prob (chi2 df) ...)
(defun chi2-1-ui (sample distrib &key (out *standard-output*) ...)
(defun chi2-2-ui (sample1 sample2 &key (out *standard-output*) ...)

string.lisp
(defun edit-distance (s1 s2 &key (test #'eql)) ...)
(defun position-limit (string string-seq limit) ...)
(defmacro string-beg-with (beg strv &optional (lenv `(length ,strv))) ...)
(defmacro string-end-with (end strv &optional (lenv `(length ,strv))) ...)
(defmacro string-beg-with-cs (beg strv &optional (lenv `(length ,strv))) ...)
(defmacro string-end-with-cs (end strv &optional (lenv `(length ,strv))) ...)
(defcustom *string-junk* string ":-,./" ...)
(defsubst purge-string (str &optional (*string-junk* *string-junk*)) ...)
(defun split-seq (seq pred &key (start 0) end key strict) ...)
(defsubst split-string (str chars &rest opts) ...)
(defun sequence-type (seq) ...)
(defun substitute-subseq-if (seq begf endf repf &key (start 0) end) ...)
(defun substitute-subseq (seq sub rep &key (start 0) end ...)
(defun remove-subseq (seq beg &optional end) ...)

symb.lisp
(defsubst symbol-concat (&rest args) ...)
(defun symbol-append (symbol &rest args) ...)
(defun symbol-prepend (symbol &rest args) ...)
(defun re-intern (symbol) ...)
(defun symbol-copy (symbol) ...)
(defconst +kwd+ package (find-package :keyword) "The KEYWORD package.") ...)
(defsubst kwd (sy-st) ...)
(defsubst keyword-concat (&rest args) ...)
(defsubst read-key (stream) ...)
(defun keyword= (key1 key2 &key (suffix1 nil suff1p) (suffix2 nil suff2p)) ...)
(defun kill-symbol (id) ...)
(defun reset-package (package &key (out *standard-output*) delete (terpri t)) ...)

tilsla.lisp
(defun commas (num &optional (dd 0 ddp) (di 0)) ...)
(defun comma (stream num colon-p atsign-p &optional (dd 0 ddp) (di 0) ...)
(defconst +internal-time-digits+ fixnum ...)
(defcustom *seconds-long-threshold* double-float 300d0 ...)
(defun pr-secs (stream sec colon-p atsign-p) ...)
(defun pr-arr (stream arr colon-p atsign-p &optional ...)
(defun print-seqs (stream fmt &rest seqs) ...)

url.lisp
(defconst +bad-url+ url (make-url) "*The convenient constant for init.") ...)
(defcustom *rfc-base* (or null string) ...)
(defun protocol-rfc (protocol) ...)
(defun protocol-port (proto) ...)
(defcustom *url-output* (or null stream) *standard-output* ...)
(defcustom *http-proxy* list nil ...)
(defun http-proxy (&optional (proxy-string (getenv "http_proxy") proxy-p)) ...)
(defun url-get-port (url) ...)
(defun url-string-p (string) ...)
(defcustom *nntp-server* simple-string ...)
(defun url-get-host (url) ...)
(defun url-path-parse (url) ...)
(defsubst url-path-dir (url) ...)
(defsubst url-path-file (url) ...)
(defsubst url-path-args (url) ...)
(defun path-absolute-p (string) ...)
(defmethod print-object ((url url) (out stream)) ...)
(defcustom *url-special-chars* simple-string "#%&*+,-./:=?@_~" ...)
(defun url-constituent-p (char) ...)
(defcustom *url-guess-protocol* list ...)
(defgeneric url (xx) ...)
(defcustom *url-sleep* (real 0) 30 ...)
(defcustom *url-timeout* (real 0) 86400 ...)
(defcustom *url-max-retry* (or null index-t) nil ...)
(defcustom *url-open-init* boolean t ...)
(defcustom *url-error* (or null stream) *error-output* ...)
(defvar *url-caller*) ...)
(defun sleep-mesg (mesg) ...)
(defsubst url-prot-bin (prot) ...)
(defun open-socket-retry (host port &key bin ...)
(defun socket-send (sock messages finish-p) ...)
(defun open-url (url &key ((:err *url-error*) *url-error*) ...)
(defcustom *url-bytes-transferred* integer 0 ...)
(defcustom *url-opening-time* (integer 0) 0 ...)
(defmacro with-open-url ((socket url &key (rt '*readtable*) ...)
(defcustom *url-user-agent* string ...)
(defun url-open-http (sock url) ...)
(defun http-parse-header (sock &key ((:out *url-output*) *url-output*)) ...)
(defcustom *url-replies* hash-table ...)
(defcustom *url-errors* hash-table ...)
(defun url-ask (sock end &rest req) ...)
(defun ftp-parse-sextuple (line) ...)
(defun ftp-get-passive-socket (sock bin) ...)
(defcustom *ftp-anonymous-passwords* list '("abc@ftp.net" "abc@") ...)
(defun url-login-ftp (sock url) ...)
(defcustom *buffer* (simple-array (unsigned-byte 8) (10240)) ...)
(defun socket-to-file (data path &key rest ((:out *url-output*) *url-output*)) ...)
(defun url-eta (len) ...)
(defun ftp-mdtm (sock file &key ((:out *url-output*) *url-output*)) ...)
(defun ftp-get-file (sock rmt loc &key (reget t) (bin t) (retry 2) ...)
(defun url-ftp-get (url loc &rest opts &key ((:out *url-output*) *url-output*) ...)
(defun ftp-list (sock &key name ((:out *url-output*) *url-output*) ...)
(defun url-send-mail (url &key ((:err *url-error*) *url-error*) ...)
(defmethod print-object ((art article) (out stream)) ...)
(defun string->article (string) ...)
(defun url-dump-to-dot (sock &key (out *standard-output*) collect) ...)
(defun url-get-news (url loc &key ((:out *url-output*) *url-output*) ...)
(defcustom *time-servers* list ...)
(defun url-time (&optional (url *time-servers*) ...)
(defcustom *browsers* list ...)
(defcustom *browser* (or symbol list) nil ...)
(defun browse-url (url &key (browser *browser*) ...)
(defun dump-url (url &key (fmt "~3d: ~a~%") ((:out *url-output*) *url-output*) ...)
(defun flush-http (sock) ...)
(defun url-get (url loc &key ((:timeout *url-timeout*) *url-timeout*) ...)
(defun whois (host &rest keys) ...)
(defun finger (address &rest keys &key gnu &allow-other-keys) ...)

withtype.lisp
(defconst +whitespace+ (simple-array character (*)) ...)
(defsubst whitespace-char-p (char) ...)
(defmacro map-vec (type len &rest args) ...)
(defmacro dfloat (num) ...)
(deftype index-t () '(unsigned-byte 28)) ...)
(defmacro with-type (type expr) ...)

inspect.lisp
(defcustom *inspect-frontend* symbol :tty ...)
(defcustom *inspect-browser* (or symbol list) nil ...)
(defcustom *inspect-print-lines* fixnum 5 ...)
(defcustom *inspect-print-level* fixnum 5 ...)
(defcustom *inspect-print-length* fixnum 10 ...)
(defcustom *inspect-length* fixnum 5 ...)
(defparameter *inspect-all* nil) ; all `inspection' objects in this session ...)
(defparameter *inspect-debug* 0) ; debug level ...)
(defvar *inspect-unbound-value*) ; the value for the unbound slots ...)
(defun insp-check (insp) ...)
(defun insp-last-slot (insp) ...)
(defun insp-num-slots-print (insp) ...)
(defun insp-left-p (insp) ...)
(defun insp-right-p (insp) ...)
(defun set-slot-error (ii obj) ...)
(defmacro with-nth-hash-slot (ht args1 args2 retform) ...)
(defgeneric inspect-backend (object &rest opts) ...)
(defun get-insp (id-or-insp com) ...)
(defgeneric print-inspection (insp out frontend &rest opts) ...)
(defgeneric inspect-frontend (insp frontend) ...)
(defgeneric inspect-finalize (frontend) ...)
(defun inspect-read-clean-eval (insp stream) ...)
(defmethod print-inspection ((insp inspection) (out stream) ...)
(defmethod inspect-frontend ((insp inspection) (frontend (eql :tty))) ...)
(defmethod print-inspection ((insp inspection) (raw stream) ...)
(defun http-command (server &key (debug *inspect-debug*) socket) ...)
(defmethod inspect-frontend ((insp inspection) (frontend (eql :http))) ...)
(defun inspect-cllib (object &key ...)

autoload.lisp
(defparameter *autoload-defun* '| ...)
(defun autoload (symb file &optional comment) ...)
(defcustom *autoload-cookie* simple-string ";;;###autoload" ...)
(defgeneric autoload-stream (in out log) ...)
(defun autoload-generate (in out &optional (log t)) ...)

htmlgen.lisp
(defcustom *html-chars* list ...)
(defclass html-stream-out (fundamental-character-output-stream) ...)
(defmethod stream-write-char ((stream html-stream-out) ch) ...)
(defmethod stream-line-column ((stream html-stream-out)) nil) ...)
(defmethod stream-finish-output ((stream html-stream-out)) ...)
(defmethod stream-force-output ((stream html-stream-out)) ...)
(defmethod stream-clear-output ((stream html-stream-out)) ...)
(defmethod close ((stream html-stream-out) &rest opts) ...)
(defmacro with-html-tag ((raw tag &rest options) &body forms) ...)
(defvar *with-html-output-doctype* ...)
(defmacro with-html-output ((var stream ...)
(defun crlf (sock) ...)
(defmacro with-http-output ((var raw &rest opts &key keep-alive (debug 0) ...)
(defun http-error (sock url &key (name "Not Found") (code 404) ...)
(defun directory-index (dir file &rest opts ...)

xml.lisp
(defpackage xml-tags (:use)) ...)
(defcustom *xml-pack* package (find-package :xml-tags) ...)
(defcustom *xml-amp* hash-table (make-hash-table :test 'equal) ...)
(defcustom *xml-per* hash-table (make-hash-table :test 'equal) ...)
(defcustom *xml-ent-file* pathname ...)
(defcustom *xml-keep-comments* boolean nil ...)
(defun xml-init-entities (&key (out *standard-output*)) ...)
(defun xml-read-entity (stream) ...)
(defun xml-entity (ent hash type &key (proc 'xml-entity) string) ...)
(defun xml-expand-entities (string &key (start 0) end) ...)
(defun xmlize-string (string) ...)
(defcustom *xml-print-xml* symbol nil ...)
(defun xml-print-readably-p () ...)
(defmethod print-object ((xm xml-misc) (out stream)) ...)
(defcustom *xml-pre-namespaces* hash-table (make-hash-table :test 'equal) ...)
(defcustom *xml-uri-namespaces* hash-table (make-hash-table :test 'equal) ...)
(defun xmlns-get (uri &rest opts &key pre-tmp (out *standard-output*) ...)
(defconst +xml-namespace-xml+ xml-namespace ...)
(defconst +xml-namespace-none+ xml-namespace ...)
(defcustom *xml-default-namespace* xml-namespace +xml-namespace-none+ ...)
(defgeneric xmln= (xn1 xn2) ...)
(defun xmln-get (name namespace) ...)
(defun xmlns-print-all (&key (out *standard-output*)) ...)
(defun xmlns-reset () ...)
(defsubst xmln-prefix (xmln) ...)
(defmethod print-object ((cmt xml-comment) (out stream)) ...)
(defmethod print-object ((ns xml-namespace) (out stream)) ...)
(defmethod print-object ((xmln xml-name) (out stream)) ...)
(defmethod print-object ((xmlt xml-tag) (out stream)) ...)
(defun xmlo-nm (tag) ...)
(defun xmlo-tag (tag name) ...)
(defmethod print-object ((xml xml-decl) (out stream)) ...)
(defsubst xmlo-long-p (obj) ...)
(defun xmlo-name-check (obj name) ...)
(defun xml-size (obj) ...)
(defun xml-ascii-p (char) (> 256 (char-code char))) ...)
(defun xml-de-unicode (string) ...)
(defun xmlo-terpri-p (xo) ...)
(defmethod print-object ((xml xml-obj) (out stream)) ...)
(defun xml-push (new xml) ...)
(defmacro do-xmlo-data ((var obj &optional ret) &body forms) ...)
(defclass xml-stream-in (fundamental-character-input-stream) ...)
(defun stream-length (st) ...)
(defmethod initialize-instance :after ((str xml-stream-in) &rest junk) ...)
(defmethod stream-read-char ((in xml-stream-in)) ...)
(defmethod stream-unread-char ((in xml-stream-in) (char character)) ...)
(defmethod stream-read-char-no-hang ((in xml-stream-in)) ...)
(defmethod stream-peek-char ((in xml-stream-in)) ...)
(defmethod stream-listen ((in xml-stream-in)) ...)
(defmethod stream-read-line ((in xml-stream-in)) ...)
(defmethod stream-clear-input ((in xml-stream-in)) ...)
(defmethod close ((in xml-stream-in) &rest opts) ...)
(defun xml-path (str &optional debug-p) ...)
(defun xmlis-push (newstr stream) ...)
(defun compress-whitespace (list &optional ends) ...)
(defun xml-read-text (str term &key (clean t) base) ...)
(defun xml-read-comment (str) ...)
(defun xml-list-to-alist (list) ...)
(defun xml-resolve-namespaces (obj &key (recursion-depth 0) ...)
(defcustom *xml-read-balanced* boolean t ...)
(defcustom *xml-read-entities* boolean t ...)
(defun xml-destructure-attributes (list) ...)
(defun xml-read-tag (str) ...)
(defun read-xml (stream char) ...)
(defun read-standalone-char (stream char) ...)
(defun make-xml-readtable (&optional (rt (copy-readtable))) ...)
(defcustom *xml-readtable* readtable (make-xml-readtable) ...)
(defmacro with-xml-input ((var stream) &body body) ...)
(defmacro with-xml-file ((var file &key reset-ent (out '*standard-output*)) ...)
(defmacro with-tag ((tag &key options (out '*standard-output*) (terpri t) ...)
(defun xml-default-reset-entities () ...)
(defun xml-read-from-file (file &key (repeat t) ...)
(defun xml-purge-data (obj) ...)
(defun xml-xhtml-remove-unused-ids (xo &key (out *standard-output*)) ...)
(defun xml-xhtml-tidy (file &key (out *standard-output*) (output file) ...)
(defun xml-mapcan (f obj) ...)
(defun xml-find-name (name &optional (namespace +xml-namespace-none+)) ...)
(defun xml-find-id (obj id &key (name (xml-find-name "id"))) ...)

prompt.lisp
(defun package-short-name (pkg) ...)
(defun set-cllib-prompt () ...)

matrix.lisp
(defun matrix-print (out aa colp atp &optional fmt-arg) ...)
(defun matrix-to-file (file matrix &key (log *standard-output*)) ...)
(defun matrix-from-file (file &key (log *standard-output*)) ...)
(defun random-matrix (rows cols max) ...)
(define-condition dimension (code) ...)
(defun matrix-id (nn) ...)
(defun array-copy (aa &optional bb) ...)
(defun matrix-symmetric-p (mx) ...)
(defun matrix-id-p (mx) ...)
(defun matrix-transpose (mx) ...)
(defun array-slice (arr index-list) ...)
(defun array-marginal (arr index-list) ...)
(defun array-dist (arr1 arr2 &key (key #'value) (order 1)) ...)
(defun list-to-array (list dims) ...)
(defun array-check-return (arr dims) ...)
(defun array-lin-comb (l0 a0 l1 a1 &optional res) ...)
(defun bilinear (mx v0 v1) ...)
(defun matrix-multiply (aa bb &optional re) ...)
(defun mx-solve-check (aa bb) ...)
(defun permuted-aref (vec ii permutation) ...)
(defun matrix-solve-lower (aa bb diag1 &optional permutation) ...)
(defun matrix-solve-upper (aa bb diag1 &optional permutation) ...)
(defsubst mx-swap-rows (mx ii jj) ...)
(defsubst mx-swap-cols (mx ii jj) ...)
(defun mx-row-pivots (mx) ...)
(defun mx-lu-sum (mx ii jj) ...)
(defun matrix-lup (mx) ...)
(defun matrix-solve-lup (mx bb) ...)
(defun matrix-lu (mx lu) ...)
(defun matrix-solve-lu (mx bb &optional (lu mx) (xx bb)) ...)
(defun matrix-inverse (mx) ...)
(defun matrix-solve (mx bb &optional (tm mx) (xx bb)) ...)

getopt.lisp
(defun parse-object (type string name) ...)
(defun getopt (arg-alist opt-alist arg-list &key (allow-less t) (allow-more t)) ...)

tests.lisp
(defparameter *network-dependent-tests* '(test-cvs)) ...)
(defmacro deftest (name (&rest extra-keys) &body body) ...)
(deftest test-string () ...)
(deftest test-math () ...)
(deftest test-date () ...)
(deftest test-rpm () ...)
(deftest test-url () ...)
(deftest test-elisp () ...)
(deftest test-xml () ...)
(deftest test-cvs () ...)
(deftest test-matrix-inverse ((num-test 10) (dim 10) (max 10)) ...)
(deftest test-matrix () ...)
(deftest test-munkres () ...)
(deftest test-base64 () ...)
(deftest test-iter () ...)
(deftest test-list () ...)
(deftest test-lift () ...)
(deftest test-bayes () ...)
(deftest test-csv () ...)
(defun test-all (&key (out *standard-output*) ...)
(defun post-compile-hook (all-files compiled-files) ...)
(defun post-compile (op) ...)
(defun post-compile (tbc) ...)

cvs.lisp
(defgeneric cvs-diff2patch (in out) ...)
(defparameter *cvs-log-sep-1* (make-string 28 :initial-element #\-)) ...)
(defparameter *cvs-log-sep-2* (make-string 77 :initial-element #\=)) ...)
(defun cvs-read-change (in ra) ...)
(defun cvs-read-file (in ra) ...)
(defun cvs-read-log (path) ...)
(defsubst rev-lines (rr) ...)
(defsubst cvsf-lines (ff) ...)
(defsubst cvsf-list-size (fl) ...)
(defsubst cvsf-dead-p (ff) ...)
(defun author-lines (au) ...)
(defmethod print-object ((au author) (out stream)) ...)
(defun cvs-stat-files (fl) ...)
(defun cvs-stat-log (path) ...)
(defun cvs-change-root (root substitutions &key (dry-run nil) (log t)) ...)
(defconst +bad-developer+ developer (make-developer) ...)
(defcustom *known-developers* list nil ...)
(defun find-dev (id) ...)
(defun string->chlen (str) ...)
(defun read-chlen (in ra) ...)
(defun read-changelog (fn) ...)
(defun read-all-changelogs (dir) ...)

rng.lisp
(deftype non-negative-float (type &optional hi) ...)
(defun ziggurat-init (n r v scale f finv) ...)
(defun gen-exponential-variate-log-method ...)
(defun gen-exponential-variate-ratio ...)
(defmacro gen-exponential-variate (mu &optional (state '*random-state*)) ...)
(defun gen-std-laplacian-variate (&optional (*random-state* *random-state*)) ...)
(defun gen-cauchy-variate-tan (&optional (*random-state* *random-state*)) ...)
(defmacro gen-cauchy-variate (&optional (state '*random-state*)) ...)
(defstruct gaussian-generator-cache ...)
(defmacro gen-gaussian-variate (&optional (state '*random-state*)) ...)
(defun gen-gamma-variate-squeeze ...)
(defun gen-gamma-variate-squeeze ...)
(defun gen-gamma-variate-gn (order &optional (*random-state* *random-state*)) ...)
(defun gen-gamma-variate-gn (order &optional (*random-state* *random-state*)) ...)
(defun gen-gamma-variate-algo-a ...)
(defun gen-gamma-variate-algo-a-2 ...)
(defun gen-gamma-variate-small-order ...)
(defun gen-gamma-variate-direct ...)
(defun gen-gamma-variate-algo-go (a &optional (*random-state* *random-state*)) ...)
(defun gen-gamma-variate-algo-go (a &optional (*random-state* *random-state*)) ...)
(defun gen-gamma-variate-ratio (a &optional (*random-state* *random-state*)) ...)
(defun gen-gamma-variate (order &optional (*random-state* *random-state*)) ...)
(defun gen-geometric-variate (p &optional (*random-state* *random-state*)) ...)
(defun gen-beta-variate (a b &optional (*random-state* *random-state*)) ...)
(defun gen-binomial-variate (ntrials p ...)
(defun gen-poisson-variate (mean &optional (*random-state* *random-state*)) ...)

csv.lisp
(defcustom *csv-separator* character #\, ...)
(defcustom *csv-first-line-names* (or t nil :default) :default ...)
(defun csv-print-vector (vec &optional (out *standard-output*)) ...)
(defcustom *csv-whitespace* (or null string) +whitespace+ ...)
(defcustom *csv-progress* integer 1000 ...)
(defcustom *csv-progress-1* integer 10 ...)
(defcustom *csv-junk* (or symbol integer) :ERROR ...)
(defun csv-trim (whitespace string) ...)
(defun csv-parse-string (string &key ...)
(defconst +comments+ string "#;" "Characters that start comments.") ...)
(defun uncomment-line (line) ...)
(defun csv-names (file) ...)
(defun csv-check-vec-len (vec cols fn pos) ...)
(defmacro with-csv ((vec file &key (progress '*csv-progress*) ...)
(defun csv-read-file (inf &key ((:junk *csv-junk*) *csv-junk*) ...)
(defun class-csv-header (class &key (out *standard-output*)) ...)
(defun class-csv-print (obj &key (out *standard-output*)) ...)
(defstruct csv-i/o ...)
(defvar *csv-i/o* (make-hash-table :test 'eq) "type -> csv-i/o") ...)
(defun new-csv (&rest args &key name &allow-other-keys) ...)
(defun csv-i/o (type) ...)
(defun csv-read (type file) ...)
(defun csv-write (type file data) ...)
(defun type-parser (slot-type) ...)
(defun type-default (slot-type) ...)
(defun type-type (slot-type) ...)
(defun set-slots-documentation (slots type) ...)
(defmacro make-reader (vec slots type package) ...)
(defmacro make-writer (obj out type) ...)
(defmacro defcsv (type (&key (package (symbol-package type))) slots ...)

base64.lisp
(defparameter *base64-table* ...)
(defun base64-encode (vec &optional buffer) ...)
(defparameter *table-base64* ...)
(defun base64-decode (str &optional buffer) ...)

lift.lisp
(defpackage :lift ...)
(defmethod print-object ((ds detector-statistics) (out stream)) ...)
(defun detector-statistics (hits true-bad predicted-bad total ...)
(defvar *min-bucket-size* 5 ...)
(defvar *default-buckets* 10 ...)
(defstruct bucket (size 0) (true 0) beg (begf #'<=) end (endf #'<=)) ...)
(defmethod print-object ((b bucket) (out stream)) ...)
(defun bucket-probability (b) ...)
(defun check-bucket (b) ...)
(defun bucket-singleton-p (b) (= (bucket-beg b) (bucket-end b))) ...)
(defun bucket-inside-p (number bucket) ...)
(defun bucket-distance (number bucket) ...)
(defun bucket-midpoint (bucket) ...)
(defun buckets-overlap-p (b1 b2) ...)
(defun bucket-empty (b) ...)
(defun bucket-empty-p (b) ...)
(defun merge-buckets (b1 b2) ...)
(defun merge-buckets-maybe (b1 b2 bsize) ...)
(defun bucket (number bucket-seq) ...)
(defun fill-buckets (seq bucket-seq &key (key #'identity) true-value) ...)
(defun show-buckets (buckets total &key (out *standard-output*)) ...)
(defun bucketize (seq buckets &key (key #'identity) (out *standard-output*)) ...)
(defun discretize-by-height (seq &key (buckets *default-buckets*) ...)
(defun prune-bucket-list (blist) ...)
(defmacro check-targets (target-count fun) ...)
(defun lift-quality (seq &key score (true-value (port:required-argument)) ...)
(defun plot-lifts (lifts &key score true-value (title "lift plot") plot ...)
(defun score2prob (seq &key score true-value (buckets *default-buckets*) ...)
(defun make-ppv (name1 1st name2 target-count total-count &aux (l (length 1st))) ...)
(defun ppv-maybe-pop (ppv curr-1st 1st-total curr-2nd 2nd-total score precision) ...)
(defun ppv-done-p (p) (= (ppv-curr p) (ppv-size p))) ...)
(defun ppv-check-done (p) (assert (ppv-done-p p) (p) "unfinished: ~S" p)) ...)
(defun ppv-out (ppv mdl out) ...)
(defun thresholds (seq &key (score (port:required-argument)) ...)

data.lisp
(defcustom *buckets* (or null (cons lift:bucket)) () ...)
(defcustom *columns* (or (eql t) (cons (or fixnum string (eql NOT)))) t ...)
(defcustom *levels* list ...)
(defun column-spec-list (col-specs names ncol) ...)
(defun columns-complement (ncol cols) ...)
(defun unroll-column-specs (col-specs names ncol) ...)
(defcustom *value-boundary* (or null double-float) (/ double-float-epsilon) ...)
(defun numeric (v i &optional names ...)
(defvar *min-name-length* 5) ...)
(defun max-name-length (names) ...)
(defun get-column-name (col) (format nil "C~D" col)) ...)
(defun get-column-names (column-count) ...)
(defun column-name (names col) ...)
(defcustom *print-bad-number-limit* fixnum 10 ...)
(defun strings-to-nums (lines col-specs &key names (len (length lines)) ...)
(defmethod print-object ((sc stat-column) (out stream)) ...)
(defun show-sc (sc &key (width 0) (out *standard-output*)) ...)
(defun show-sc-list (sc-list &key (out *standard-output*)) ...)
(defun aref-i (i) (lambda (v) (aref v i))) ...)
(defun stat-column (lines col names &key (out *standard-output*) ...)
(defun ensure-buckets (sc &key (out *standard-output*) ...)
(defun ensure-levels (sc &key (out *standard-output*) ...)
(defstruct table ...)
(defun table-lines$ (table) ...)
(defun table-column-pos (name table) ...)
(defun table-accessor (name table) ...)
(defun write-table (tab out) ...)
(defmethod print-object ((tab table) (out stream)) ...)
(defvar *tables* nil "The list of currently loaded tables") ...)
(defun compress-tables () ...)
(defun table-stat-column (pos-or-name table &key (out *standard-output*) ...)
(defun ensure-table-stat-column (name table) ...)
(defun maybe-ensure-table-stat-column (pos name table) ...)
(defun column-histogram (sc &rest plot-opts) ...)
(defun column-histogram2 (name table &rest plot-opts) ...)
(defun analyse-csv (file &key ...)
(defun table-stats-refresh (table) ...)
(defun coerce-int-float (num) ...)
(defun table-copy (table) ...)
(defun add-column (table1 function name) ...)
(defun column-name-sc (obj table) ...)
(defun table-to-hash (table column &key (out *standard-output*)) ...)
(defun plot-columns (table col1 col2 &rest options ...)
(defun correlation-columns (table col1 col2 &key (out *standard-output*)) ...)
(defun restat-table (old-table new-table &key (out *standard-output*) ...)
(defun summarize (table column &key (out *standard-output*) (slots '(mn sd))) ...)
(defun table-select (table &key column (value t) predicate ...)
(defun list->intervals (list) ...)
(defun extract-columns (vec columns) ...)
(defun purge-columns (table &key (test 'equal) (out *standard-output*)) ...)
(defun evaluate-predictor (file &optional (out *standard-output*)) ...)

ocaml.lisp
(defmacro def-sexp-to (class-name &key junk-allowed) ...)
(defun fix-slot (name line &key (start 0) (end (length line))) ...)

bayes.lisp
(defstruct nb-model ...)
(defun nb-model-check (model) ...)
(defun nb-model-copy (model) ...)
(defmethod print-object ((model nb-model) (out stream)) ...)
(defun nb-model-make (name class-names &key (feature-test 'equal)) ...)
(defun feature-counts (model feature) ...)
(defun nb-model-merge (model1 model2 new-name) ...)
(defun nb-class-index (model class) ...)
(defun nb-add-observation (model class features &key (weight 1)) ...)
(defun feature-weight (counts) ...)
(defun feature-power (counts) ...)
(defun feature-groups (model &key (key #'value) (test #'eql)) ...)
(defcustom *nb-describe-feature-count* integer 10 ...)
(defcustom *nb-describe-feature-grouper* (or symbol function) nil ...)
(defmethod describe-object ((model nb-model) (out stream)) ...)
(defcustom *prune-methods* list ...)
(defun nb-model-prune (model feature-quality threshold ...)
(defun logodds (this total) ...)
(defgeneric logodds-to-prob (lo) ...)
(defun logodds+ (lo0 lo1) ...)
(defun nb-predict-classes (model features) ...)
(defun best-class (logodds) ...)
(defun nb-evaluate (model observations &key (key #'identity) ...)
(defun nb-boost-once (model observations &key (key #'identity)) ...)
(defun nb-boost (model train test &key (key #'identity) (repeat t) ...)
(defun train-test (observations &key (key #'identity) (out *standard-output*) ...)

grepfin.lisp
(defpackage #:grepfin ...)
(defcustom *data-dir* pathname (merge-pathnames "data/" (user-homedir-pathname)) ...)
(defcustom *fund-dir* pathname (merge-pathnames "funds/" *data-dir*) ...)
(defpackage "FIN" (:use)) ...)
(defcsv holding (:package "FIN") ...)
(defun holdings-total-value (holdings) ...)
(defvar *holding-total-value*)  ; the total value of the current holding ...)
(defun holding-stock (holding) ...)
(defun holding-%-of-fund (holding) ...)
(defun holding-%-of-stock (holding) ...)
(defun holding-market-cap (holding) ...)
(defmacro defstar (f) ...)
(defstar <) ...)
(defstar <=) ...)
(defstar >) ...)
(defstar >=) ...)
(defvar *funds* (make-hash-table :test 'equalp)) ...)
(defun read-fund (file) ...)
(defun read-funds (&key (dir *fund-dir*)) ...)
(defvar *funds-db* (merge-pathnames "funds.sexp" *data-dir*)) ...)
(defun save-funds (&key (file *funds-db*)) ...)
(defun load-funds (&key (file *funds-db*)) ...)
(defun ensure-funds (&key (dir *fund-dir*)) ...)
(defcsv stock (:package "FIN") ...)
(defcustom *stock-file* pathname ...)
(defvar *stocks* ()) ...)
(defun read-stocks (&key (file *stock-file*)) ...)
(defun ensure-data (&optional force) ...)
(defun show-readers (type) ...)
(defun show-extras (extras) ...)
(defgeneric query-stocks (query &key csv) ...)
(defgeneric query-funds (query &key csv) ...)
(defun init () ...)
(defun parse-request (request) ...)
(defun report-error (sock text &aux ...)
(defmacro bad (sock fmt &rest args) ...)
(defun make-query (realm queries) ...)
(defun run-request (list sock) ...)
(defun server (&optional port) ...)
